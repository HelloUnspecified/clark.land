---
export interface Props {
  children: any;
  delay?: number;
  direction?: 'up' | 'down' | 'left' | 'right' | 'fade';
  duration?: number;
}

const { delay = 0, direction = 'up', duration = 600 } = Astro.props;
---

<div 
  class="scroll-reveal"
  data-delay={delay}
  data-duration={duration}
  data-direction={direction}
  style={`
    opacity: 0;
    filter: blur(4px);
    transition: opacity ${duration}ms ease-out, filter ${duration}ms ease-out;
    transition-delay: ${delay}ms;
  `}
>
  <slot />
</div>

<script>
  class ScrollReveal {
    private observer: IntersectionObserver;
    private elements: NodeListOf<Element>;

    constructor() {
      this.elements = document.querySelectorAll('.scroll-reveal');
      this.setupObserver();
      this.observeElements();
    }

    private setupObserver() {
      const options = {
        threshold: 0.15,
        rootMargin: '0px 0px -50px 0px'
      };

      this.observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            this.revealElement(entry.target as HTMLElement);
          }
        });
      }, options);
    }

    private observeElements() {
      this.elements.forEach((element) => {
        this.observer.observe(element);
      });
    }

    private revealElement(element: HTMLElement) {
      const direction = element.dataset.direction || 'up';
      
      // Add a small delay to ensure smooth animation
      requestAnimationFrame(() => {
        element.style.opacity = '1';
        element.style.filter = 'blur(0px)';
        
        // Add subtle slide effect using margin instead of transform
        if (direction === 'up') {
          element.style.marginTop = '-10px';
          setTimeout(() => {
            element.style.marginTop = '0px';
            element.style.transition = `${element.style.transition}, margin-top 300ms ease-out`;
          }, 50);
        }
        
        // Unobserve after animation to improve performance
        setTimeout(() => {
          this.observer.unobserve(element);
        }, parseInt(element.dataset.duration || '600') + parseInt(element.dataset.delay || '0') + 100);
      });
    }
  }

  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    new ScrollReveal();
  });

  // Re-initialize on navigation (for SPA-like behavior)
  document.addEventListener('astro:page-load', () => {
    new ScrollReveal();
  });
</script>